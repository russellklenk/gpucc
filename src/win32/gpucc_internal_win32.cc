/**
 * gpucc_win32.cc: Implement the Windows-specific portions of the internal 
 * GpuCC library interface, along with the startup and shutdown routines.
 */
#include <assert.h>
#include <stdarg.h>
#include <stdio.h>
#include <wchar.h>
#include "gpucc.h"
#include "gpucc_internal.h"

/* @summary Helper function to emit printf-style output to OutputDebugString.
 * The output can be viewed in the VS debugger output window or using DbgView.
 * GpuCC pipes debug output from startup and loading functions to this endpoint.
 * @param format A nul-terminated wide character string following printf formatting conventions.
 * @param ... Substitution arguments for the format string.
 */
static void
DebugPrintfW
(
    LPCWSTR format, 
    ...
)
{
    WCHAR buffer[2048];
    va_list       args;
    size_t      mchars = sizeof(buffer) / sizeof(WCHAR);
    int         nchars;

    va_start(args, format);
    nchars = vswprintf_s(buffer, format, args);
    va_end(args);
    if (nchars < 0) {
        assert(0 && "Error formatting debug output");
        OutputDebugStringW(L"GpuCC: Error formatting debug output.\n");
        return;
    }
    UNREFERENCED_PARAMETER(mchars);
    assert(nchars  <  (int)mchars && "Increase DebugPrintfW buffer size");
    OutputDebugStringW(buffer);
}

/* @summary Write a nul-terminated UTF-8 encoded string to a buffer.
 * @param dst A pointer to the address where the string should be written. On return, points to one-past the nul byte in the buffer.
 * @param src A pointer to the start of the nul-terminated source string to copy.
 * @return A pointer to the start of the string in the destination buffer.
 */
static char*
strputa
(
    uint8_t   *&dst, 
    char const *src
)
{
    char *p  =(char*) dst;
    if (src != nullptr) {
        size_t nb = strlen(src);
        memcpy(dst, src, nb); 
        dst += nb; /* string data */
    }
   *dst  = 0;  /* put nul */
    dst += 1;  /* nul */
    return p;
}

/* @summary Write a nul-terminated UTF-16 encoded string to a buffer.
 * @param dst A pointer to the address where the string should be written. On return, points to one-past the nul byte in the buffer.
 * @param src A pointer to the start of the nul-terminated source string to copy.
 * @return A pointer to the start of the string in the destination buffer.
 */
#if 0
static WCHAR*
strputw
(
    uint8_t    *&dst, 
    WCHAR const *src
)
{
    WCHAR *p =(WCHAR*) dst;
    if (src != nullptr) {
        size_t nb = wcslen(src) * sizeof(WCHAR);
        memcpy(dst, src, nb);
        dst += nb; /* string data */
    }
   *dst++ = 0; /* nul byte 0 */
   *dst++ = 0; /* nul byte 1 */
    return p;
}
#endif

/* @summary Parse a Direct3D shader model target profile of the format "ss_j_i", where ss indicates the shader stage, j indicates the shader model major version, and i indicates the shader model minor version.
 * @param target A nul-terminated string specifying the Direct3D shader model.
 * @param o_stage Pointer to a three-byte buffer that on return stores the nul-terminated shader stage string, for example "cs", "vs", "gs" or "fs".
 * @param o_sm_major On return, stores the major version component of the shader model target profile.
 * @param o_sm_minor On return, stores the minor version component of the shader model target profile.
 * @return Zero if the shader model was successfully parsed, or non-zero if the target string could not be parsed.
 */
static int
gpuccExtractDirect3DShaderModel
(
    char const *target, 
    char    o_stage[3], 
    int    *o_sm_major, 
    int    *o_sm_minor
)
{
    unsigned int level_major = 0;
    unsigned int level_minor = 0;
    char                 st0 = 0;
    char                 st1 = 0;
    int              nbmatch = 0;

    if ((nbmatch = sscanf_s(target, "%c%c_%u_%u", &st0, 1, &st1, 1, &level_major, &level_minor)) == 4) {
        o_stage[0] = st0;
        o_stage[1] = st1;
        o_stage[2] = 0;
       *o_sm_major =(int) level_major;
       *o_sm_minor =(int) level_minor;
        return  0;
    } else { /* The target profile string doesn't match the expected format. */
        o_stage[0] = 0;
        o_stage[1] = 0;
        o_stage[2] = 0;
       *o_sm_major = 0;
       *o_sm_minor = 0;
        return -1;
    }
}

/* @summary Allocate and initialize a bytecode container for DXBC bytecode generated by the fxc (legacy Direct3D) compiler.
 * @param compiler A pointer to an instance of GPUCC_COMPILER_FXC_WIN32.
 * @return A pointer to the bytecode container, of type GPUCC_BYTECODE_FXC_WIN32, or NULL if the allocation failed.
 */
static struct GPUCC_PROGRAM_BYTECODE*
gpuccCreateProgramBytecodeFxc
(
    struct GPUCC_PROGRAM_COMPILER *compiler
)
{
    GPUCC_BYTECODE_FXC_WIN32 *code = nullptr;

    if ((code = (GPUCC_BYTECODE_FXC_WIN32*) malloc(sizeof(GPUCC_BYTECODE_FXC_WIN32))) == nullptr) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_OUT_OF_HOST_MEMORY);
        DebugPrintfW(L"GpuCC: Failed to allocate %Iu bytes to create FXC bytecode.\n", sizeof(GPUCC_BYTECODE_FXC_WIN32));
        gpuccSetLastResult(r);
        return nullptr;
    } memset(code, 0, sizeof(GPUCC_BYTECODE_FXC_WIN32));

    /* TODO: Increment ref count on compiler object? */

    code->CommonFields.Compiler        = compiler;
    code->CommonFields.CompileResult   = gpuccMakeResult(GPUCC_RESULT_CODE_EMPTY_BYTECODE_CONTAINER);
    code->CommonFields.EntryPoint      = nullptr; /* Set on compile */
    code->CommonFields.SourcePath      = nullptr; /* Set on compile */
    code->CommonFields.LogBuffer       = nullptr; /* Set on compile */
    code->CommonFields.LogBufferSize   = 0;       /* Set on compile */
    code->CommonFields.BytecodeSize    = 0;       /* Set on compile */
    code->CommonFields.BytecodeBuffer  = nullptr; /* Set on compile */
    code->CodeBuffer                   = nullptr; /* Set on compile */
    code->ErrorLog                     = nullptr; /* Set on compile */
    return (struct GPUCC_PROGRAM_BYTECODE*) code;
}

/* @summary Release all resources associated with a fxc program bytecode container.
 * @param bytecode A pointer to an instance of GPUCC_BYTECODE_FXC_WIN32.
 */
static void
gpuccDeleteProgramBytecodeFxc
(
    struct GPUCC_PROGRAM_BYTECODE *bytecode
)
{
    GPUCC_BYTECODE_FXC_WIN32 *code = gpuccBytecodeFxc_(bytecode);

    if (code->ErrorLog != nullptr) {
        ID3DBlob  *log  = code->ErrorLog;
        code->CommonFields.LogBufferSize  = 0;
        code->CommonFields.LogBuffer      = nullptr;
        code->ErrorLog                    = nullptr;
        log->Release();
    }
    if (code->CodeBuffer != nullptr) {
        ID3DBlob    *buf  = code->CodeBuffer;
        code->CommonFields.BytecodeBuffer = nullptr;
        code->CommonFields.BytecodeSize   = 0;
        code->CodeBuffer                  = nullptr;
        buf->Release();
    }
    if (code->CommonFields.EntryPoint != nullptr) {
        free(code->CommonFields.EntryPoint);
        code->CommonFields.EntryPoint  = nullptr;
        code->CommonFields.SourcePath  = nullptr;
    }
    /* TODO: Decrement ref count on compiler object? */
}

static struct GPUCC_RESULT
gpuccCompileBytecodeFxc
(
    struct GPUCC_PROGRAM_BYTECODE *container, 
    char const                  *source_code, 
    uint64_t                     source_size, 
    char const                  *source_path, 
    char const                  *entry_point
)
{
    GPUCC_COMPILER_FXC_WIN32  *compiler_ = gpuccCompilerFxc_(gpuccQueryBytecodeCompiler_(container));
    GPUCC_BYTECODE_FXC_WIN32 *container_ = gpuccBytecodeFxc_(container);
    FXCCOMPILERAPI_DISPATCH    *dispatch = compiler_->DispatchTable;
    GPUCC_RESULT                  result = gpuccMakeResult(GPUCC_RESULT_CODE_SUCCESS);
    ID3DBlob                       *code = nullptr;
    ID3DBlob                        *log = nullptr;
    HRESULT                          res = S_OK;
    DWORD                         flags1 = D3DCOMPILE_DEBUG | D3DCOMPILE_WARNINGS_ARE_ERRORS;
    DWORD                         flags2 = 0;

    /* TODO: Need some way to specify flags1 */
    res = dispatch->D3DCompile
    (
        source_code, 
        source_size, 
        source_path, 
        compiler_->DefineArray, 
        nullptr, /* ID3DInclude* pInclude */
        entry_point, 
        compiler_->ShaderModel, 
        flags1, 
        flags2, 
        &code, 
        &log
    );
    if (FAILED(res)) {
        result = gpuccMakeResult(GPUCC_RESULT_CODE_COMPILE_FAILED);
    }

    if (code != nullptr) {
        container_->CommonFields.BytecodeSize   =(uint64_t) code->GetBufferSize();
        container_->CommonFields.BytecodeBuffer =(uint8_t*) code->GetBufferPointer();
    } else {
        container_->CommonFields.BytecodeSize   = 0;
        container_->CommonFields.BytecodeBuffer = nullptr;
    } container_->CodeBuffer = code;

    if (log != nullptr) {
        container_->CommonFields.LogBufferSize  =(uint64_t) log->GetBufferSize();
        container_->CommonFields.LogBuffer      =(char   *) log->GetBufferPointer();
    } else {
        container_->CommonFields.LogBufferSize  = 0;
        container_->CommonFields.LogBuffer      = nullptr;
    } container_->ErrorLog = log;

    return result;
}

/* @summary Allocate and initialize a new compiler record for accessing the fxc (legacy Direct3D) compiler.
 * @param config Data used to configure the compiler instance.
 * @return A pointer to the compiler, or NULL if an error occurred.
 */
static struct GPUCC_PROGRAM_COMPILER*
gpuccCreateCompilerFxc
(
    struct GPUCC_PROGRAM_COMPILER_INIT *config
)
{   // Assume that config has been validated by gpuccCreateCompiler.
    GPUCC_PROCESS_CONTEXT_WIN32 *pctx = gpuccGetProcessContext_();
    GPUCC_COMPILER_FXC_WIN32     *fxc = nullptr;
    D3D_SHADER_MACRO          *macros = nullptr;
    uint8_t                     *base = nullptr;
    uint8_t                      *ptr = nullptr;
    size_t                     nbneed = 0;
    int                    version_mj = 0;
    int                    version_mi = 0;
    char               shader_type[3] ={0, 0, 0};

    /* Validate the target profile. */
    if (config->TargetProfile == nullptr) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_TARGET_PROFILE);
        DebugPrintfW(L"GpuCC: A target profile, for example, \"cs_5_0\", is required by the FXC compiler.\n");
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (gpuccExtractDirect3DShaderModel(config->TargetProfile, shader_type, &version_mj, &version_mi) != 0) {
        /* The TargetProfile string doesn't match the expected format. */
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_TARGET_PROFILE);
        DebugPrintfW(L"GpuCC: Invalid target profile \"%S\" for the FXC compiler.\n", config->TargetProfile);
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (_stricmp(shader_type, "cs") != 0 && 
        _stricmp(shader_type, "vs") != 0 && 
        _stricmp(shader_type, "ps") != 0 && 
        _stricmp(shader_type, "gs") != 0) {
        /* The target profile specifies an unexpected shader type. */
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_TARGET_PROFILE);
        DebugPrintfW(L"GpuCC: Invalid target profile \"%S\". Unexpected shader type \'%s\'.\n", config->TargetProfile, shader_type);
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (version_mj < 4) {
        /* Legacy D3D9 shader models are not supported. */
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_TARGET_PROFILE);
        DebugPrintfW(L"GpuCC: Invalid target profile \"%S\". Legacy shader models are not supported.\n", config->TargetProfile);
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (version_mj > 5) {
        /* Shader Model 6 and later requires using the newer dxc compiler. */
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_TARGET_PROFILE);
        DebugPrintfW(L"GpuCC: Invalid target profile \"%S\". Shader model 6+ require the newer dxc compiler and DXIL bytecode format.\n", config->TargetProfile);
        gpuccSetLastResult(r);
        return nullptr;
    }

    /* Determine the amount of memory required. */
    nbneed += sizeof(GPUCC_COMPILER_FXC_WIN32);
    nbneed += sizeof(D3D_SHADER_MACRO) * (config->DefineCount + 1);
    nbneed += strlen(config->TargetProfile) + 1;
    for (uint32_t i = 0, n = config->DefineCount; i < n; ++i) {
        nbneed += strlen(config->DefineSymbols[i]) + 1;
        nbneed += strlen(config->DefineValues [i]) + 1;
    }

    /* Allocate as a single block. */
    if ((base = (uint8_t*) malloc(nbneed)) == nullptr) {
        GPUCC_RESULT  _r = gpuccMakeResult(GPUCC_RESULT_CODE_OUT_OF_HOST_MEMORY);
        DebugPrintfW(L"GpuCC: Failed to allocate %Iu bytes to create FXC compiler.\n", nbneed);
        gpuccSetLastResult(_r);
        return nullptr;
    }
    fxc    =(GPUCC_COMPILER_FXC_WIN32*) base;
    ptr    = base + sizeof(GPUCC_COMPILER_FXC_WIN32);

    /* The array of D3D_SHADER_MACRO structures immediately follows the 
     * compiler record. The entries are initialized when interning the 
     * strings below.
     */
    macros =(D3D_SHADER_MACRO *) ptr;
    ptr   += sizeof(D3D_SHADER_MACRO) * (config->DefineCount + 1);

    /* Copy string data into the memory block. */
    fxc->ShaderModel = strputa(ptr, config->TargetProfile);
    for (uint32_t  i = 0, n = config->DefineCount; i < n; ++i) {
        macros[i].Name          = strputa(ptr, config->DefineSymbols[i]);
        macros[i].Definition    = strputa(ptr, config->DefineValues [i]);
    }
    /* The macro array is always terminated with a null entry. */
    macros[config->DefineCount] = D3D_SHADER_MACRO { nullptr, nullptr };

    /* Finish initializing the compiler structure. */
    fxc->CommonFields.CompilerType        = GPUCC_COMPILER_TYPE_FXC;
    fxc->CommonFields.BytecodeType        = GPUCC_BYTECODE_TYPE_DXBC;
    fxc->CommonFields.CreateBytecode      = gpuccCreateProgramBytecodeFxc;
    fxc->CommonFields.DeleteBytecode      = gpuccDeleteProgramBytecodeFxc;
    fxc->CommonFields.CompileBytecode     = gpuccCompileBytecodeFxc;
    fxc->DispatchTable                    =&pctx->FxcCompiler_Dispatch;
    fxc->DefineArray                      = macros;
    fxc->DefineCount                      = config->DefineCount;
    fxc->TargetRuntime                    = config->TargetRuntime;
    return (struct GPUCC_PROGRAM_COMPILER*) fxc;
}

GPUCC_API(struct GPUCC_RESULT)
gpuccMakeResult
(
    int32_t library_result
)
{
    return GPUCC_RESULT { library_result, ERROR_SUCCESS };
}

GPUCC_API(struct GPUCC_RESULT)
gpuccMakeResult_errno
(
    int32_t library_result
)
{
    return GPUCC_RESULT { library_result, (int32_t) errno };
}

GPUCC_API(struct GPUCC_RESULT)
gpuccMakeResult_Win32
(
    int32_t library_result, 
    DWORD  platform_result
)
{
    return GPUCC_RESULT { library_result, (int32_t) platform_result };
}

GPUCC_API(struct GPUCC_RESULT)
gpuccMakeResult_HRESULT
(
    HRESULT platform_result
)
{
    GPUCC_RESULT r;
    if (FAILED(platform_result)) {
        r.LibraryResult  = GPUCC_RESULT_CODE_PLATFORM_ERROR;
        r.PlatformResult =(int32_t) platform_result;
    } else {
        r.LibraryResult  = GPUCC_RESULT_CODE_SUCCESS;
        r.PlatformResult =(int32_t) platform_result;
    } return r;
}

GPUCC_API(struct GPUCC_RESULT)
gpuccGetLastResult
(
    void
)
{
    GPUCC_THREAD_CONTEXT_WIN32 *tctx = gpuccGetThreadContext_();
    return tctx->LastResult;
}

GPUCC_API(struct GPUCC_RESULT)
gpuccSetLastResult
(
    struct GPUCC_RESULT result
)
{
    GPUCC_THREAD_CONTEXT_WIN32 *tctx = gpuccGetThreadContext_();
    GPUCC_RESULT                prev = tctx->LastResult;
    tctx->LastResult = result;
    return prev;
}

GPUCC_API(struct GPUCC_RESULT)
gpuccSetProgramEntryPoint
(
    struct GPUCC_PROGRAM_BYTECODE *bytecode, 
    char const                 *entry_point, 
    char const                 *source_path
)
{
    GPUCC_PROGRAM_BYTECODE_BASE *bytecode_ =(GPUCC_PROGRAM_BYTECODE_BASE*) bytecode;
    GPUCC_RESULT                    result = gpuccMakeResult(GPUCC_RESULT_CODE_SUCCESS);
    uint8_t                        *buffer = nullptr;
    uint8_t                           *ptr = nullptr;
    size_t                          nbneed = 0;
    size_t                          nbpath = 0;
    size_t                         nbentry = 0;

    /* Determine the amount of memory required to store copies of the strings. */
    nbentry = (entry_point != nullptr) ? (strlen(entry_point) + 1) : 1;
    nbpath  = (source_path != nullptr) ? (strlen(source_path) + 1) : 1;
    nbneed  = nbentry + nbpath;

    /* Allocate memory for all string data in one buffer. */
    if ((buffer = (uint8_t*) malloc(nbneed)) == nullptr) {
        result  = gpuccMakeResult_errno(GPUCC_RESULT_CODE_OUT_OF_HOST_MEMORY);
        DebugPrintfW(L"GpuCC: Failed to allocate %Iu bytes for storing program entry point.\n", nbneed);
        gpuccSetLastResult(result);
        return result;
    } ptr = buffer;

    /* Write the string data to the buffer. */
    bytecode_->EntryPoint = strputa(ptr, entry_point);
    bytecode_->SourcePath = strputa(ptr, source_path);
    return result;
}

GPUCC_API(int32_t)
gpuccBytecodeContainerIsEmpty
(
    struct GPUCC_PROGRAM_BYTECODE *bytecode
)
{
    if (bytecode != nullptr) {
        GPUCC_RESULT r = gpuccQueryBytecodeCompileResult_(bytecode);
        return r.LibraryResult == GPUCC_RESULT_CODE_EMPTY_BYTECODE_CONTAINER;
    } else {
        assert(0 && "Invalid bytecode container");
        return 0;
    }
}

GPUCC_API(struct GPUCC_RESULT)
gpuccStartup
(
    uint32_t gpucc_usage_mode
)
{
    GPUCC_PROCESS_CONTEXT_WIN32 *pctx = gpuccGetProcessContext_();
    GPUCC_RESULT               result = gpuccMakeResult(GPUCC_RESULT_CODE_SUCCESS);
    uint32_t        fxccompiler_flags = FXCCOMPILERAPI_LOADER_FLAGS_NONE;

    if (gpucc_usage_mode != GPUCC_USAGE_MODE_OFFLINE && 
        gpucc_usage_mode != GPUCC_USAGE_MODE_RUNTIME) {
        return gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_USAGE_MODE);
    }
    if (pctx->StartupFlag != FALSE) {
        return gpuccMakeResult(GPUCC_RESULT_CODE_ALREADY_INITIALIZED);
    }

    /* When being used in offline mode, enable development-only features. */
    if (gpucc_usage_mode  == GPUCC_USAGE_MODE_OFFLINE) {
        fxccompiler_flags |= FXCCOMPILERAPI_LOADER_FLAG_DEVELOPMENT;
    }

    /* Populate dispatch tables for any available compilers. */
    pctx->CompilerSupport = GPUCC_COMPILER_SUPPORT_NONE;
    if (FxcCompilerApiPopulateDispatch(&pctx->FxcCompiler_Dispatch, fxccompiler_flags) != 0) {
        pctx->CompilerSupport |= GPUCC_COMPILER_SUPPORT_FXC;
    }
    /* ... */
    pctx->StartupFlag = TRUE;
    return result;
}

GPUCC_API(void)
gpuccShutdown
(
    void
)
{
    GPUCC_PROCESS_CONTEXT_WIN32 *pctx = gpuccGetProcessContext_();

    /* Invalidate the dispatch tables for any available compilers. */
    FxcCompilerApiInvalidateDispatch(&pctx->FxcCompiler_Dispatch);
    /* ... */

    pctx->CompilerSupport = GPUCC_COMPILER_SUPPORT_NONE;
    pctx->StartupFlag     = FALSE;
}

GPUCC_API(struct GPUCC_PROGRAM_COMPILER*)
gpuccCreateCompiler
(
    struct GPUCC_PROGRAM_COMPILER_INIT *config
)
{
    GPUCC_PROCESS_CONTEXT_WIN32   *pctx = gpuccGetProcessContext_();
    GPUCC_COMPILER_TYPE   compiler_type = GPUCC_COMPILER_TYPE_UNKNOWN;
    GPUCC_COMPILER_SUPPORT need_support = GPUCC_COMPILER_SUPPORT_NONE;
    struct GPUCC_PROGRAM_COMPILER    *c = nullptr;

    if (pctx->StartupFlag == FALSE) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_NOT_INITIALIZED);
        DebugPrintfW(L"GpuCC: Cannot create compiler. Call gpuccStartup() first.\n");
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (config == nullptr) {
        assert(config != nullptr);
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_ARGUMENT);
        DebugPrintfW(L"GpuCC: No compliler configuration was specified.\n");
        gpuccSetLastResult(r);
        return nullptr;
    }
    if (config->DefineCount > 0 && (config->DefineSymbols == nullptr || config->DefineValues == nullptr)) {
        assert(config->DefineSymbols != nullptr);
        assert(config->DefineValues  != nullptr);
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_ARGUMENT);
        DebugPrintfW(L"GpuCC: DefineCount is non-zero, but symbols or values array is not specified.\n");
        gpuccSetLastResult(r);
        return nullptr;
    }
    switch (config->BytecodeType) {
        case GPUCC_BYTECODE_TYPE_UNKNOWN:
            break;
        case GPUCC_BYTECODE_TYPE_DXIL:
            compiler_type = GPUCC_COMPILER_TYPE_DXC;
            need_support  = GPUCC_COMPILER_SUPPORT_DXC;
            break;
        case GPUCC_BYTECODE_TYPE_DXBC:
            compiler_type = GPUCC_COMPILER_TYPE_FXC;
            need_support  = GPUCC_COMPILER_SUPPORT_FXC;
            break;
        case GPUCC_BYTECODE_TYPE_SPIRV:
            compiler_type = GPUCC_COMPILER_TYPE_SHADERC;
            need_support  = GPUCC_COMPILER_SUPPORT_SHADERC;
            break;
        case GPUCC_BYTECODE_TYPE_PTX:
            compiler_type = GPUCC_COMPILER_TYPE_NVRTC;
            need_support  = GPUCC_COMPILER_SUPPORT_NVRTC;
            break;
        default:
            break;
    }
    if (compiler_type == GPUCC_COMPILER_TYPE_UNKNOWN) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_BYTECODE_TYPE);
        DebugPrintfW(L"GpuCC: Unable to determine compiler type from bytecode type %s.\n", gpuccBytecodeTypeString(config->BytecodeType));
        gpuccSetLastResult(r);
        return nullptr;
    }
    if ((pctx->CompilerSupport & need_support) == 0) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_COMPILER_NOT_SUPPORTED);
        DebugPrintfW(L"GpuCC: The required compiler type %s is not supported on this host platform.\n", gpuccCompilerTypeString(compiler_type));
        gpuccSetLastResult(r);
        return nullptr;
    }

    switch (compiler_type) {
        case GPUCC_COMPILER_TYPE_UNKNOWN:
            c = nullptr;
            break;
        case GPUCC_COMPILER_TYPE_DXC:
            c = nullptr;
            break;
        case GPUCC_COMPILER_TYPE_FXC:
            c = gpuccCreateCompilerFxc(config);
            break;
        case GPUCC_COMPILER_TYPE_SHADERC:
            c = nullptr;
            break;
        case GPUCC_COMPILER_TYPE_NVRTC:
            c = nullptr;
            break;
        default:
            c = nullptr;
            break;
    }
    return c;
}

GPUCC_API(void)
gpuccDeleteCompiler
(
    struct GPUCC_PROGRAM_COMPILER *compiler
)
{
    free(compiler);
}

GPUCC_API(struct GPUCC_PROGRAM_BYTECODE*)
gpuccCreateBytecodeContainer
(
    struct GPUCC_PROGRAM_COMPILER *compiler
)
{
    struct GPUCC_PROGRAM_COMPILER_BASE *compiler_ =(GPUCC_PROGRAM_COMPILER_BASE*) compiler;

    if (compiler == nullptr) {
        GPUCC_RESULT r = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_ARGUMENT);
        DebugPrintfW(L"GpuCC: A valid GPUCC_PROGRAM_COMPILER must be specified to gpuccCreateBytecodeContainer.\n");
        gpuccSetLastResult(r);
        return nullptr;
    }

    return compiler_->CreateBytecode(compiler);
}

GPUCC_API(void)
gpuccDeleteBytecodeContainer
(
    struct GPUCC_PROGRAM_BYTECODE *bytecode
)
{
    if (bytecode) {
        struct GPUCC_PROGRAM_COMPILER_BASE *compiler_ =(GPUCC_PROGRAM_COMPILER_BASE*) gpuccQueryBytecodeCompiler_(bytecode);
        assert(compiler_ != nullptr);
        compiler_->DeleteBytecode(bytecode);
    }
}

GPUCC_API(struct GPUCC_RESULT)
gpuccCompileProgramBytecode
(
    struct GPUCC_PROGRAM_BYTECODE *container, 
    char const                  *source_code, 
    uint64_t                     source_size, 
    char const                  *source_path, 
    char const                  *entry_point
)
{
    GPUCC_PROGRAM_BYTECODE_BASE *container_ = nullptr;
    GPUCC_PROGRAM_COMPILER_BASE  *compiler_ = nullptr;
    GPUCC_RESULT                     result = gpuccMakeResult(GPUCC_RESULT_CODE_SUCCESS);

    if (container == nullptr) {
        result = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_ARGUMENT);
        DebugPrintfW(L"GpuCC: No bytecode container was supplied.\n");
        gpuccSetLastResult(result);
        return result;
    }
    if (source_code == nullptr || source_size == 0) {
        result = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_ARGUMENT);
        DebugPrintfW(L"GpuCC: No program source code was supplied.\n");
        gpuccSetLastResult(result);
        return result;
    }
    if (gpuccBytecodeContainerIsEmpty(container) == 0) {
        result = gpuccMakeResult(GPUCC_RESULT_CODE_INVALID_BYTECODE_CONTAINER);
        DebugPrintfW(L"GpuCC: The supplied bytecode container has already been used to compile a program and cannot be reused.\n");
        gpuccSetLastResult(result);
        return result;
    }

    /* Intern strings used for debug output. */
    container_ =(GPUCC_PROGRAM_BYTECODE_BASE*) container;
    compiler_  =(GPUCC_PROGRAM_COMPILER_BASE*) gpuccQueryBytecodeCompiler(container);
    if (gpuccFailure((result = gpuccSetProgramEntryPoint(container, entry_point, source_path)))) {
        /* gpuccSetProgramEntryPoint called gpuccSetLastResult  */
        DebugPrintfW(L"GpuCC: Cannot copy program entry point and source path. Compilation cannot proceed.\n");
        return result;
    }

    /* Finally, perform the actual compilation. */
    result = compiler_->CompileBytecode(container, source_code, source_size, container_->SourcePath, container_->EntryPoint);
    gpuccSetLastResult(gpuccMakeResult(GPUCC_RESULT_CODE_SUCCESS));
    return result;
}

